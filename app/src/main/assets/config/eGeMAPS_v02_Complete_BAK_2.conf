///////////////////////////////////////////////////////////////////////////////////////
///////// > openSMILE configuration file, Geneva feature set <       //////////////////
/////////                                                            //////////////////
///////// (c) 2014, 2020 by audEERING                                //////////////////
/////////     All rights reserved. See file COPYING for details.     //////////////////
///////////////////////////////////////////////////////////////////////////////////////

;;;;;;; component list ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

[componentInstances:cComponentManager]
instance[dataMemory].type=cDataMemory
printLevelStats=0

;;;;;;;;;;;;;;;;;;;;;;;;;;;; main section ;;;;;;;;;;;;;;;;;;;;;;;;;;;

//\{../../shared/standard_wave_input.conf.inc}
///////////////////////////////////////////////////////////////////////////////////////
///////// > openSMILE configuration file for wave input <            //////////////////
/////////                                                            //////////////////
///////// (c) audEERING GmbH,                                        //////////////////
/////////     All rights reserved.                                  //////////////////
///////////////////////////////////////////////////////////////////////////////////////



[componentInstances:cComponentManager]
instance[waveIn].type=cWaveSource

[waveIn:cWaveSource]
writer.dmLevel=wave
buffersize_sec = 5.0
filename=\cm[inputfile(I){test.wav}:name of input file]
start=\cm[start{0}:audio start position in seconds]
end=\cm[end{-1}:audio end position in seconds, -1 for end of file]
monoMixdown=1
outFieldName = pcm


//\{../../gemaps/v01b/GeMAPSv01b_core.lld.conf.inc}
///////////////////////////////////////////////////////////////////////////////////////
///////// > openSMILE configuration file, Geneva feature set <       //////////////////
/////////                                                            //////////////////
///////// (c) 2014, 2020 by audEERING                                //////////////////
/////////     All rights reserved. See file COPYING for details.     //////////////////
///////////////////////////////////////////////////////////////////////////////////////

;;;;;;;;;;;;;;;;;;;;;;

[componentInstances:cComponentManager]
instance[gemapsv01b_frame60].type=cFramer
instance[gemapsv01b_win60].type=cWindower
instance[gemapsv01b_fft60].type=cTransformFFT
instance[gemapsv01b_fftmp60].type=cFFTmagphase

[gemapsv01b_frame60:cFramer]
reader.dmLevel=wave
writer.dmLevel=gemapsv01b_frame60
\{\cm[bufferModeRbConf{../../shared/BufferModeRb.conf.inc}:path to included config to set the buffer mode for the standard ringbuffer levels]}
frameSize = 0.060
frameStep = 0.010
frameCenterSpecial = left

[gemapsv01b_win60:cWindower]
reader.dmLevel=gemapsv01b_frame60
writer.dmLevel=gemapsv01b_winG60
winFunc=gauss
gain=1.0
sigma=0.4

[gemapsv01b_fft60:cTransformFFT]
reader.dmLevel=gemapsv01b_winG60
writer.dmLevel=gemapsv01b_fftcG60

[gemapsv01b_fftmp60:cFFTmagphase]
reader.dmLevel=gemapsv01b_fftcG60
writer.dmLevel=gemapsv01b_fftmagG60
\{\cm[bufferModeRbLagConf{../../shared/BufferModeRbLag.conf.inc}:path to included config to set the buffer mode for levels which will be joint with Viterbi smoothed -lagged- F0]}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

[componentInstances:cComponentManager]
instance[gemapsv01b_frame25].type=cFramer
instance[gemapsv01b_win25].type=cWindower
instance[gemapsv01b_fft25].type=cTransformFFT
instance[gemapsv01b_fftmp25].type=cFFTmagphase

[gemapsv01b_frame25:cFramer]
reader.dmLevel=wave
writer.dmLevel=gemapsv01b_frame25
\{\cm[bufferModeRbConf]}
frameSize = 0.020
frameStep = 0.010
frameCenterSpecial = left

[gemapsv01b_win25:cWindower]
reader.dmLevel=gemapsv01b_frame25
writer.dmLevel=gemapsv01b_winH25
winFunc=hamming

[gemapsv01b_fft25:cTransformFFT]
reader.dmLevel=gemapsv01b_winH25
writer.dmLevel=gemapsv01b_fftcH25

[gemapsv01b_fftmp25:cFFTmagphase]
reader.dmLevel=gemapsv01b_fftcH25
writer.dmLevel=gemapsv01b_fftmagH25
;;; CHECK!!!!!!!
;writer.levelconf.growDyn = 1
;writer.levelconf.isRb = 0


;;;;;;;;;;;;;;;;;;;; HPS pitch

[componentInstances:cComponentManager]
instance[gemapsv01b_scale].type=cSpecScale
instance[gemapsv01b_shs].type=cPitchShs

[gemapsv01b_scale:cSpecScale]
reader.dmLevel=gemapsv01b_fftmagG60
writer.dmLevel=gemapsv01b_hpsG60
\{\cm[bufferModeRbConf]}
copyInputName = 1
processArrayFields = 0
scale=octave
sourceScale = lin
interpMethod = spline
minF = 25
maxF = -1
nPointsTarget = 0
specSmooth = 1
specEnhance = 1
auditoryWeighting = 1

[gemapsv01b_shs:cPitchShs]
reader.dmLevel=gemapsv01b_hpsG60
writer.dmLevel=gemapsv01b_pitchShsG60
\{\cm[bufferModeRbLagConf]}
copyInputName = 1
processArrayFields = 0
maxPitch = 1000
minPitch = 55
nCandidates = 6
scores = 1
voicing = 1
F0C1 = 0
voicingC1 = 0
F0raw = 1
voicingClip = 1
voicingCutoff = 0.700000
inputFieldSearch = Mag_octScale
octaveCorrection = 0
nHarmonics = 15
compressionFactor = 0.850000
greedyPeakAlgo = 1

;;;;; Pitch with Viterbi smoother
[componentInstances:cComponentManager]
instance[gemapsv01b_energy60].type=cEnergy

[gemapsv01b_energy60:cEnergy]
reader.dmLevel=gemapsv01b_winG60
writer.dmLevel=gemapsv01b_e60
 ; This must be > than buffersize of viterbi smoother
 ; writer.levelconf.nT=100
\{\cm[bufferModeRbLagConf]}
rms=1
log=0

[componentInstances:cComponentManager]
instance[gemapsv01b_pitchSmoothViterbi].type=cPitchSmootherViterbi

[gemapsv01b_pitchSmoothViterbi:cPitchSmootherViterbi]
reader.dmLevel=gemapsv01b_pitchShsG60
reader2.dmLevel=gemapsv01b_pitchShsG60
writer.dmLevel=gemapsv01b_logPitchRaw
copyInputName = 1
bufferLength=40
F0final = 1
F0finalLog = 1
F0finalEnv = 0
voicingFinalClipped = 0
voicingFinalUnclipped = 1
F0raw = 0
voicingC1 = 0
voicingClip = 0
wTvv =10.0
wTvvd= 5.0
wTvuv=10.0
wThr = 4.0
wTuu = 0.0
wLocal=2.0
wRange=1.0

[componentInstances:cComponentManager]
instance[gemapsv01b_volmerge].type = cValbasedSelector

[gemapsv01b_volmerge:cValbasedSelector]
reader.dmLevel = gemapsv01b_e60;gemapsv01b_logPitchRaw
writer.dmLevel = gemapsv01b_logPitch
\{\cm[bufferModeRbLagConf]}
idx=0
threshold=0.001
removeIdx=1
zeroVec=1
outputVal=0.0

;;;;;;;;;;;;;;;;;;; Voice Quality (VQ)

[componentInstances:cComponentManager]
instance[gemapsv01b_pitchJitter].type=cPitchJitter

[gemapsv01b_pitchJitter:cPitchJitter]
reader.dmLevel = wave
writer.dmLevel = gemapsv01b_jitterShimmer
\{\cm[bufferModeRbLagConf]}
copyInputName = 1
F0reader.dmLevel = gemapsv01b_logPitch
F0field = F0final
searchRangeRel = 0.100000
jitterLocal = 1
jitterDDP = 0
jitterLocalEnv = 0
jitterDDPEnv = 0
shimmerLocal = 0
shimmerLocalDB = 1
shimmerLocalEnv = 0
onlyVoiced = 0
logHNR = 0
 ; This must be larger than the viterbi pitch smoother lag
inputMaxDelaySec = 2.5
minNumPeriods = 2
minCC = 0.5
useBrokenJitterThresh = 0

;;;;;;;;;;;;;;;;;;;;; Energy / loudness


[componentInstances:cComponentManager]
instance[gemapsv01b_melspec1].type=cMelspec
instance[gemapsv01b_audspec].type=cPlp
instance[gemapsv01b_audspecSum].type=cVectorOperation

[gemapsv01b_melspec1:cMelspec]
reader.dmLevel=gemapsv01b_fftmagH25
writer.dmLevel=gemapsv01b_melspec1
; htk compatible sample value scaling
htkcompatible = 0
nBands = 26
; use power spectrum instead of magnitude spectrum
usePower = 1
lofreq = 20
hifreq = 8000
specScale = mel
showFbank = 0

; perform auditory weighting of spectrum
[gemapsv01b_audspec:cPlp]
reader.dmLevel=gemapsv01b_melspec1
writer.dmLevel=gemapsv01b_audspec
firstCC = 0
lpOrder = 5
cepLifter = 22
compression = 0.33
htkcompatible = 0
doIDFT = 0
doLpToCeps = 0
doLP = 0
doInvLog = 0
doAud = 1
doLog = 0
newRASTA=0
RASTA=0

[gemapsv01b_audspecSum:cVectorOperation]
reader.dmLevel = gemapsv01b_audspec
writer.dmLevel = gemapsv01b_loudness
; This must be larger than the F0 viterbi buffer length
; since audspecSum and F0 envelope are joint later!
\{\cm[bufferModeRbLagConf]}
nameAppend = loudness
copyInputName = 0
processArrayFields = 0
operation = ll1
nameBase = loudness

;;;;;;;;;;;;;; Formants ;;;;;;;;;;;;;;;;;;;;;;
[componentInstances:cComponentManager]
instance[gemapsv01b_resampLpc].type=cSpecResample
instance[gemapsv01b_lpc].type=cLpc
instance[gemapsv01b_formantLpc].type=cFormantLpc

[gemapsv01b_resampLpc:cSpecResample]
// use fftcG60 ?  H25 has faster resampling
reader.dmLevel=gemapsv01b_fftcH25
writer.dmLevel=gemapsv01b_outpR
targetFs = 11000

[gemapsv01b_lpc:cLpc]
reader.dmLevel=gemapsv01b_outpR
writer.dmLevel=gemapsv01b_lpc
p=11
method=acf
lpGain=0
saveLPCoeff=1
residual=0
forwardFilter=0
lpSpectrum=0

[gemapsv01b_formantLpc:cFormantLpc]
reader.dmLevel=gemapsv01b_lpc
writer.dmLevel=gemapsv01b_formants
\{\cm[bufferModeRbLagConf]}
saveIntensity=0
saveBandwidths=1
maxF=5450.0
minF=50.0
nFormants=5
useLpSpec=0
medianFilter=0
octaveCorrection=0

;;;;;;;;;;;;; Harmonics ;;;;;;;;;;;;;;;;;;;;
[componentInstances:cComponentManager]
instance[gemapsv01b_harmonics].type = cHarmonics

  ;;;; default (template) configuration section for component 'cHarmonics' ;;;;
[gemapsv01b_harmonics:cHarmonics]
reader.dmLevel = gemapsv01b_logPitch;gemapsv01b_formants;gemapsv01b_fftmagG60
writer.dmLevel = gemapsv01b_harmonics
\{\cm[bufferModeRbLagConf]}
copyInputName = 0
processArrayFields = 0
includeSingleElementFields = 1
preserveFieldNames = 0
formantFrequencyFieldName = formantFreqLpc
formantFrequencyFieldNameIsFull = 1
formantBandwidthFieldName = formantBandwidthLpc
formantBandwidthFieldNameIsFull = 1
f0ElementName = F0final
f0ElementNameIsFull = 1
magSpecFieldName = pcm_fftMag
magSpecFieldNameIsFull = 1
nHarmonics = 100
harmonicDifferences = H1-H2;H1-A3
harmonicDifferencesLog = 1
nHarmonicMagnitudes = 0
firstHarmonicMagnitude = 1
outputLogRelMagnitudes = 1
formantAmplitudes=1
formantAmplitudesLogRel = 1
formantAmplitudesStart = 1
formantAmplitudesEnd = 3
computeAcfHnrLogdB = 1

;;;;;;;;;;;;;;; spectral
[componentInstances:cComponentManager]
instance[gemapsv01b_logSpectral].type=cSpectral

[gemapsv01b_logSpectral:cSpectral]
reader.dmLevel=gemapsv01b_fftmagH25
writer.dmLevel=gemapsv01b_logSpectral
\{\cm[bufferModeRbLagConf]}
flux = 0
centroid = 0
maxPos=0
minPos=0
entropy = 0
flatness = 0
harmonicity = 0
sharpness = 0
variance=0
skewness=0
kurtosis=0
alphaRatio = 1
hammarbergIndex = 1
slope = 0
slopes[0] = 0-500
slopes[1] = 500-1500
  ; NOTE: added this to sync with eGeMAPS set, should have no effect.
normBandEnergies = 1
squareInput = 1
useLogSpectrum = 1
freqRange = 0-5000
oldSlopeScale = 0

;;;;;;;;;;;; collecting, filtering, and renaming ;;;;;;;;;;;;;;;;,

/*
logSpectral     Hammarberg, AlphaRatio, spectralSlope  0-500, 500-1500
harmonics   H1-H2, H1-A3, HNRlog
logPitch    F0finalLog
jitterShimmer   jitterLocal, shimmerLocal
loudness
formants   F1-3 freq, F1 bandw (check!)
harmonics  F1-3 level relative
*/

[componentInstances:cComponentManager]
instance[gemapsv01b_lldSetSelectorE].type=cDataSelector
instance[gemapsv01b_lldSetSelectorF].type=cDataSelector
instance[gemapsv01b_lldSetSelectorLogF0].type=cDataSelector
instance[gemapsv01b_formantVoiced].type = cValbasedSelector
instance[gemapsv01b_lldSetSelectorNoF0LoudnNz].type = cDataSelector
instance[gemapsv01b_logSpectralVoiced].type = cValbasedSelector
instance[gemapsv01b_logSpectralUnvoiced].type = cValbasedSelector
instance[gemapsv01b_lldSetSelectorSpectralNz].type=cDataSelector
instance[gemapsv01b_lldSetSelectorSpectralZ].type=cDataSelector

[gemapsv01b_lldSetSelectorE:cDataSelector]
reader.dmLevel = gemapsv01b_loudness;gemapsv01b_logSpectral
writer.dmLevel = gemapsv01b_lldsetE
\{\cm[bufferModeRbConf]}
selected = loudness;pcm_fftMag_alphaRatioDB;pcm_fftMag_hammarbergIndexDB;pcm_fftMag_logSpectralSlopeOfBand0-500;pcm_fftMag_logSpectralSlopeOfBand500-1500
newNames = Loudness;alphaRatio;hammarbergIndex;slope0-500;slope500-1500

[gemapsv01b_lldSetSelectorF:cDataSelector]
reader.dmLevel = gemapsv01b_logPitch;gemapsv01b_jitterShimmer;gemapsv01b_harmonics;gemapsv01b_formants
writer.dmLevel = gemapsv01b_lldsetF
\{\cm[bufferModeRbConf]}
selected = F0finalLog;jitterLocal;shimmerLocalDB;HarmonicsToNoiseRatioACFLogdB;HarmonicDifferenceLogRelH1-H2;HarmonicDifferenceLogRelH1-A3;formantFreqLpc[1];formantBandwidthLpc[1];FormantAmplitudeByMaxHarmonicLogRelF0[1];formantFreqLpc[2];FormantAmplitudeByMaxHarmonicLogRelF0[2];formantFreqLpc[3];FormantAmplitudeByMaxHarmonicLogRelF0[3]
newNames = F0semitoneFrom27.5Hz;jitterLocal;shimmerLocaldB;HNRdBACF;logRelF0-H1-H2;logRelF0-H1-A3;F1frequency;F1bandwidth;F1amplitudeLogRelF0;F2frequency;F2amplitudeLogRelF0;F3frequency;F3amplitudeLogRelF0

[gemapsv01b_lldSetSelectorLogF0:cDataSelector]
reader.dmLevel = gemapsv01b_logPitch
writer.dmLevel = gemapsv01b_lld_single_logF0
\{\cm[bufferModeRbLagConf]}
selected = F0finalLog
newNames = F0semitoneFrom27.5Hz

// select only formants where F0 > 0 for functionals
// (in LLD csv we output all of them..!)
[gemapsv01b_formantVoiced:cValbasedSelector]
reader.dmLevel = gemapsv01b_lld_single_logF0;gemapsv01b_formants
writer.dmLevel = gemapsv01b_formantsNz
\{\cm[bufferModeRbLagConf]}
idx=0
threshold=0.000001
removeIdx=1
zeroVec=1
outputVal=0.0

[gemapsv01b_lldSetSelectorNoF0LoudnNz:cDataSelector]
reader.dmLevel = gemapsv01b_jitterShimmer;gemapsv01b_harmonics;gemapsv01b_formantsNz
writer.dmLevel = gemapsv01b_lldSetNoF0AndLoudnessNz
\{\cm[bufferModeRbConf]}
selected = jitterLocal;shimmerLocalDB;HarmonicsToNoiseRatioACFLogdB;HarmonicDifferenceLogRelH1-H2;HarmonicDifferenceLogRelH1-A3;formantFreqLpc[1];formantBandwidthLpc[1];FormantAmplitudeByMaxHarmonicLogRelF0[1];formantFreqLpc[2];FormantAmplitudeByMaxHarmonicLogRelF0[2];formantFreqLpc[3];FormantAmplitudeByMaxHarmonicLogRelF0[3]
newNames = jitterLocal;shimmerLocaldB;HNRdBACF;logRelF0-H1-H2;logRelF0-H1-A3;F1frequency;F1bandwidth;F1amplitudeLogRelF0;F2frequency;F2amplitudeLogRelF0;F3frequency;F3amplitudeLogRelF0

// select logspectral for voiced sounds
[gemapsv01b_logSpectralVoiced:cValbasedSelector]
reader.dmLevel = gemapsv01b_lld_single_logF0;gemapsv01b_logSpectral
writer.dmLevel = gemapsv01b_logSpectralVoiced
\{\cm[bufferModeRbLagConf]}
idx=0
threshold=0.000001
removeIdx=1
zeroVec=1
outputVal=0.0

// select logspectral for voiced sounds
[gemapsv01b_logSpectralUnvoiced:cValbasedSelector]
reader.dmLevel = gemapsv01b_lld_single_logF0;gemapsv01b_logSpectral
writer.dmLevel = gemapsv01b_logSpectralUnvoiced
\{\cm[bufferModeRbLagConf]}
idx=0
invert = 1
threshold = 0.000001
removeIdx=1
zeroVec=1
outputVal=0.0

[gemapsv01b_lldSetSelectorSpectralNz:cDataSelector]
reader.dmLevel = gemapsv01b_logSpectralVoiced
writer.dmLevel = gemapsv01b_lldSetSpectralNz
\{\cm[bufferModeRbConf]}
selected = pcm_fftMag_alphaRatioDB;pcm_fftMag_hammarbergIndexDB;pcm_fftMag_logSpectralSlopeOfBand0-500;pcm_fftMag_logSpectralSlopeOfBand500-1500
newNames = alphaRatioV;hammarbergIndexV;slopeV0-500;slopeV500-1500

[gemapsv01b_lldSetSelectorSpectralZ:cDataSelector]
reader.dmLevel = gemapsv01b_logSpectralUnvoiced
writer.dmLevel = gemapsv01b_lldSetSpectralZ
\{\cm[bufferModeRbConf]}
selected = pcm_fftMag_alphaRatioDB;pcm_fftMag_hammarbergIndexDB;pcm_fftMag_logSpectralSlopeOfBand0-500;pcm_fftMag_logSpectralSlopeOfBand500-1500
newNames = alphaRatioUV;hammarbergIndexUV;slopeUV0-500;slopeUV500-1500


;;;;;;;;;;;;;;;;  smoothing ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
[componentInstances:cComponentManager]
instance[gemapsv01b_smoFnz].type=cContourSmoother
instance[gemapsv01b_smoE].type=cContourSmoother
instance[gemapsv01b_smoNoF0andLoudnNz].type=cContourSmoother
instance[gemapsv01b_smoSpectralZ].type=cContourSmoother
instance[gemapsv01b_smoSpectralNz].type=cContourSmoother

[gemapsv01b_smoFnz:cContourSmoother]
reader.dmLevel = gemapsv01b_lldsetF
writer.dmLevel = gemapsv01b_lldsetF_smo
nameAppend = sma3nz
copyInputName = 1
noPostEOIprocessing = 0
smaWin = 3
noZeroSma = 1

[gemapsv01b_smoE:cContourSmoother]
reader.dmLevel = gemapsv01b_lldsetE
writer.dmLevel = gemapsv01b_lldsetE_smo
nameAppend = sma3
copyInputName = 1
noPostEOIprocessing = 0
smaWin = 3
noZeroSma = 0

[gemapsv01b_smoNoF0andLoudnNz:cContourSmoother]
reader.dmLevel = gemapsv01b_lldSetNoF0AndLoudnessNz
writer.dmLevel = gemapsv01b_lldSetNoF0AndLoudnessNz_smo
\{\cm[bufferModeConf{../../shared/BufferMode.conf.inc}:path to included config to set the buffer mode for the levels before the functionals]}
nameAppend = sma3nz
copyInputName = 1
noPostEOIprocessing = 0
smaWin = 3
noZeroSma = 1

[gemapsv01b_smoSpectralZ:cContourSmoother]
reader.dmLevel = gemapsv01b_lldSetSpectralZ
writer.dmLevel = gemapsv01b_lldSetSpectralZ_smo
\{\cm[bufferModeConf]}
nameAppend = sma3nz
copyInputName = 1
noPostEOIprocessing = 0
smaWin = 3
; non-zero SMA is ok here, as it is inverted with 0's for the voiced parts
noZeroSma = 1

[gemapsv01b_smoSpectralNz:cContourSmoother]
reader.dmLevel = gemapsv01b_lldSetSpectralNz
writer.dmLevel = gemapsv01b_lldSetSpectralNz_smo
\{\cm[bufferModeConf]}
nameAppend = sma3nz
copyInputName = 1
noPostEOIprocessing = 0
smaWin = 3
noZeroSma = 1








//\{eGeMAPSv02_core.lld.conf.inc}
///////////////////////////////////////////////////////////////////////////////////////
///////// > openSMILE configuration file, Geneva feature set <       //////////////////
/////////                                                            //////////////////
///////// (c) 2014, 2020 by audEERING                                //////////////////
/////////     All rights reserved. See file COPYING for details.     //////////////////
///////////////////////////////////////////////////////////////////////////////////////

;; for LEq
[componentInstances:cComponentManager]
instance[egemapsv02_energyRMS].type=cEnergy

[egemapsv02_energyRMS:cEnergy]
reader.dmLevel = gemapsv01b_frame25
writer.dmLevel = egemapsv02_energyRMS
\{\cm[bufferModeConf]}
htkcompatible = 0
rms = 0
energy2 = 1
log = 0


;;;;;;;;;;;;;;; spectral
[componentInstances:cComponentManager]
instance[egemapsv02_logSpectral_flux].type=cSpectral

[egemapsv02_logSpectral_flux:cSpectral]
reader.dmLevel=gemapsv01b_fftmagH25
writer.dmLevel=egemapsv02_logSpectral_flux
\{\cm[bufferModeRbLagConf]}
flux = 1
centroid = 0
maxPos=0
minPos=0
entropy = 0
flatness = 0
harmonicity = 0
sharpness = 0
variance=0
skewness=0
kurtosis=0
alphaRatio = 0
hammarbergIndex = 0
slope = 0
normBandEnergies = 1
squareInput = 1
useLogSpectrum = 1
freqRange = 0-5000
oldSlopeScale = 0

;;;;;;;;;; cepstral ;;;;;;;;;;;;;;;;;;;
[componentInstances:cComponentManager]
instance[egemapsv02_melspecMfcc].type=cMelspec
instance[egemapsv02_mfcc].type=cMfcc

[egemapsv02_melspecMfcc:cMelspec]
reader.dmLevel=gemapsv01b_fftmagH25
writer.dmLevel=egemapsv02_melspecMfcc
copyInputName = 1
processArrayFields = 1
; htk compatible sample value scaling
htkcompatible = 1
nBands = 26
; use power spectrum instead of magnitude spectrum
usePower = 1
lofreq = 20
hifreq = 8000
specScale = mel
inverse = 0

[egemapsv02_mfcc:cMfcc]
reader.dmLevel=egemapsv02_melspecMfcc
writer.dmLevel=egemapsv02_mfcc
\{\cm[bufferModeRbLagConf]}
copyInputName = 0
processArrayFields = 1
firstMfcc = 1
lastMfcc  = 4
cepLifter = 22.0
htkcompatible = 1


;;;;;;;;;;;; collecting, filtering, and renaming ;;;;;;;;;;;;;;;;,

/*
logSpectral     Hammarberg, AlphaRatio, spectralSlope  0-500, 500-1500
harmonics   H1-H2, H1-A3, HNRlog
logPitch    F0finalLog
jitterShimmer   jitterLocal, shimmerLocal
loudness
formants   F1-3 freq, F1 bandw (check!)
harmonics  F1-3 level relative
*/

[componentInstances:cComponentManager]
instance[egemapsv02_lldSetSelectorE].type=cDataSelector
instance[egemapsv02_lldSetSelectorF].type=cDataSelector
instance[egemapsv02_lldSetSelectorNoF0LoudnZ].type=cDataSelector
instance[egemapsv02_lldSetSelectorNoF0LoudnNz].type = cDataSelector
instance[egemapsv02_logSpectralVoiced].type = cValbasedSelector
instance[egemapsv02_logSpectralUnvoiced].type = cValbasedSelector
instance[egemapsv02_lldSetSelectorSpectralNz].type=cDataSelector
instance[egemapsv02_lldSetSelectorSpectralZ].type=cDataSelector

[egemapsv02_lldSetSelectorE:cDataSelector]
reader.dmLevel = gemapsv01b_loudness;gemapsv01b_logSpectral;egemapsv02_logSpectral_flux;egemapsv02_mfcc
writer.dmLevel = egemapsv02_lldsetE
\{\cm[bufferModeRbConf]}
selected = loudness;pcm_fftMag_alphaRatioDB;pcm_fftMag_hammarbergIndexDB;pcm_fftMag_logSpectralSlopeOfBand0-500;pcm_fftMag_logSpectralSlopeOfBand500-1500;pcm_fftMag_spectralFlux;mfcc[1];mfcc[2];mfcc[3];mfcc[4]
newNames = Loudness;alphaRatio;hammarbergIndex;slope0-500;slope500-1500;spectralFlux;mfcc1;mfcc2;mfcc3;mfcc4

[egemapsv02_lldSetSelectorF:cDataSelector]
reader.dmLevel = gemapsv01b_logPitch;gemapsv01b_jitterShimmer;gemapsv01b_harmonics;gemapsv01b_formants
writer.dmLevel = egemapsv02_lldsetF
\{\cm[bufferModeRbConf]}
selected = F0finalLog;jitterLocal;shimmerLocalDB;HarmonicsToNoiseRatioACFLogdB;HarmonicDifferenceLogRelH1-H2;HarmonicDifferenceLogRelH1-A3;formantFreqLpc[1];formantBandwidthLpc[1];FormantAmplitudeByMaxHarmonicLogRelF0[1];formantFreqLpc[2];formantBandwidthLpc[2];FormantAmplitudeByMaxHarmonicLogRelF0[2];formantFreqLpc[3];formantBandwidthLpc[3];FormantAmplitudeByMaxHarmonicLogRelF0[3]
newNames = F0semitoneFrom27.5Hz;jitterLocal;shimmerLocaldB;HNRdBACF;logRelF0-H1-H2;logRelF0-H1-A3;F1frequency;F1bandwidth;F1amplitudeLogRelF0;F2frequency;F2bandwidth;F2amplitudeLogRelF0;F3frequency;F3bandwidth;F3amplitudeLogRelF0

[egemapsv02_lldSetSelectorNoF0LoudnZ:cDataSelector]
 ; gemapsv01b_logSpectral
reader.dmLevel = egemapsv02_logSpectral_flux;egemapsv02_mfcc
writer.dmLevel = egemapsv02_lldSetNoF0AndLoudnessZ
\{\cm[bufferModeRbConf]}
selected = pcm_fftMag_spectralFlux;mfcc[1];mfcc[2];mfcc[3];mfcc[4]
newNames = spectralFlux;mfcc1;mfcc2;mfcc3;mfcc4

[egemapsv02_lldSetSelectorNoF0LoudnNz:cDataSelector]
reader.dmLevel = gemapsv01b_jitterShimmer;gemapsv01b_harmonics;gemapsv01b_formantsNz
writer.dmLevel = egemapsv02_lldSetNoF0AndLoudnessNz
\{\cm[bufferModeRbConf]}
selected = jitterLocal;shimmerLocalDB;HarmonicsToNoiseRatioACFLogdB;HarmonicDifferenceLogRelH1-H2;HarmonicDifferenceLogRelH1-A3;formantFreqLpc[1];formantBandwidthLpc[1];FormantAmplitudeByMaxHarmonicLogRelF0[1];formantFreqLpc[2];formantBandwidthLpc[2];FormantAmplitudeByMaxHarmonicLogRelF0[2];formantFreqLpc[3];formantBandwidthLpc[3];FormantAmplitudeByMaxHarmonicLogRelF0[3]
newNames = jitterLocal;shimmerLocaldB;HNRdBACF;logRelF0-H1-H2;logRelF0-H1-A3;F1frequency;F1bandwidth;F1amplitudeLogRelF0;F2frequency;F2bandwidth;F2amplitudeLogRelF0;F3frequency;F3bandwidth;F3amplitudeLogRelF0

// select logspectral and mfcc for voiced sounds
[egemapsv02_logSpectralVoiced:cValbasedSelector]
reader.dmLevel = gemapsv01b_lld_single_logF0;gemapsv01b_logSpectral;egemapsv02_logSpectral_flux;egemapsv02_mfcc
writer.dmLevel = egemapsv02_logSpectralVoiced
\{\cm[bufferModeRbLagConf]}
idx=0
threshold=0.000001
removeIdx=1
zeroVec=1
outputVal=0.0

// select logspectral and mfcc for voiced sounds
[egemapsv02_logSpectralUnvoiced:cValbasedSelector]
reader.dmLevel = gemapsv01b_lld_single_logF0;gemapsv01b_logSpectral;egemapsv02_logSpectral_flux
writer.dmLevel = egemapsv02_logSpectralUnvoiced
\{\cm[bufferModeRbLagConf]}
idx=0
invert = 1
threshold = 0.000001
removeIdx=1
zeroVec=1
outputVal=0.0

[egemapsv02_lldSetSelectorSpectralNz:cDataSelector]
reader.dmLevel = egemapsv02_logSpectralVoiced
writer.dmLevel = egemapsv02_lldSetSpectralNz
\{\cm[bufferModeRbConf]}
selected = pcm_fftMag_alphaRatioDB;pcm_fftMag_hammarbergIndexDB;pcm_fftMag_logSpectralSlopeOfBand0-500;pcm_fftMag_logSpectralSlopeOfBand500-1500;pcm_fftMag_spectralFlux;mfcc[1];mfcc[2];mfcc[3];mfcc[4]
newNames = alphaRatioV;hammarbergIndexV;slopeV0-500;slopeV500-1500;spectralFluxV;mfcc1V;mfcc2V;mfcc3V;mfcc4V

[egemapsv02_lldSetSelectorSpectralZ:cDataSelector]
reader.dmLevel = egemapsv02_logSpectralUnvoiced
writer.dmLevel = egemapsv02_lldSetSpectralZ
\{\cm[bufferModeRbConf]}
selected = pcm_fftMag_alphaRatioDB;pcm_fftMag_hammarbergIndexDB;pcm_fftMag_logSpectralSlopeOfBand0-500;pcm_fftMag_logSpectralSlopeOfBand500-1500;pcm_fftMag_spectralFlux
newNames = alphaRatioUV;hammarbergIndexUV;slopeUV0-500;slopeUV500-1500;spectralFluxUV


;;;;;;;;;;;;;;;;  smoothing ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
[componentInstances:cComponentManager]
instance[egemapsv02_smoFnz].type=cContourSmoother
instance[egemapsv02_smoE].type=cContourSmoother
instance[egemapsv02_smoNoFLZ].type=cContourSmoother
instance[egemapsv02_smoNoF0andLoudnNz].type=cContourSmoother
instance[egemapsv02_smoSpectralZ].type=cContourSmoother
instance[egemapsv02_smoSpectralNz].type=cContourSmoother

[egemapsv02_smoFnz:cContourSmoother]
reader.dmLevel = egemapsv02_lldsetF
writer.dmLevel = egemapsv02_lldsetF_smo
nameAppend = sma3nz
copyInputName = 1
noPostEOIprocessing = 0
smaWin = 3
noZeroSma = 1

[egemapsv02_smoE:cContourSmoother]
reader.dmLevel = egemapsv02_lldsetE
writer.dmLevel = egemapsv02_lldsetE_smo
nameAppend = sma3
copyInputName = 1
noPostEOIprocessing = 0
smaWin = 3
noZeroSma = 0

[egemapsv02_smoNoFLZ:cContourSmoother]
reader.dmLevel = egemapsv02_lldSetNoF0AndLoudnessZ
writer.dmLevel = egemapsv02_lldSetNoF0AndLoudnessZ_smo
\{\cm[bufferModeConf]}
nameAppend = sma3
copyInputName = 1
noPostEOIprocessing = 0
smaWin = 3
noZeroSma = 0

[egemapsv02_smoNoF0andLoudnNz:cContourSmoother]
reader.dmLevel = egemapsv02_lldSetNoF0AndLoudnessNz
writer.dmLevel = egemapsv02_lldSetNoF0AndLoudnessNz_smo
\{\cm[bufferModeConf]}
nameAppend = sma3nz
copyInputName = 1
noPostEOIprocessing = 0
smaWin = 3
noZeroSma = 1

[egemapsv02_smoSpectralZ:cContourSmoother]
reader.dmLevel = egemapsv02_lldSetSpectralZ
writer.dmLevel = egemapsv02_lldSetSpectralZ_smo
\{\cm[bufferModeConf]}
nameAppend = sma3nz
copyInputName = 1
noPostEOIprocessing = 0
smaWin = 3
; non-zero SMA is ok here, as it is inverted with 0's for the voiced parts
noZeroSma = 1

[egemapsv02_smoSpectralNz:cContourSmoother]
reader.dmLevel = egemapsv02_lldSetSpectralNz
writer.dmLevel = egemapsv02_lldSetSpectralNz_smo
\{\cm[bufferModeConf]}
nameAppend = sma3nz
copyInputName = 1
noPostEOIprocessing = 0
smaWin = 3
noZeroSma = 1

//\{../../gemaps/v01b/GeMAPSv01b_core.func.conf.inc}
///////////////////////////////////////////////////////////////////////////////////////
///////// > openSMILE configuration file, Geneva feature set <       //////////////////
/////////                                                            //////////////////
///////// (c) 2014, 2020 by audEERING                                //////////////////
/////////     All rights reserved. See file COPYING for details.     //////////////////
///////////////////////////////////////////////////////////////////////////////////////

;;;;;;;;;;;;;;;; temporal statistics: ;;;;;;;;;;;;;;;;;;;;;;

[componentInstances:cComponentManager]
instance[gemapsv01b_smoF0].type=cContourSmoother
instance[gemapsv01b_smoLoudness].type=cContourSmoother
instance[gemapsv01b_temporalF0].type=cFunctionals
instance[gemapsv01b_temporalF0p].type=cFunctionals
instance[gemapsv01b_temporalLoudness].type=cFunctionals
instance[gemapsv01b_temporalSetNames].type=cDataSelector

;;smoothing ;;
[gemapsv01b_smoF0:cContourSmoother]
reader.dmLevel = gemapsv01b_lld_single_logF0
writer.dmLevel = gemapsv01b_lld_single_logF0_smo
\{\cm[bufferModeConf]}
copyInputName = 1
nameAppend = sma3nz
noPostEOIprocessing = 0
smaWin = 3
noZeroSma = 1

[gemapsv01b_smoLoudness:cContourSmoother]
reader.dmLevel = gemapsv01b_loudness
writer.dmLevel = gemapsv01b_loudness_smo
\{\cm[bufferModeConf]}
nameAppend = sma3
copyInputName = 1
noPostEOIprocessing = 0
smaWin = 3
noZeroSma = 0

; functionals for pitch onsets/offsets
[gemapsv01b_temporalF0:cFunctionals]
reader.dmLevel = gemapsv01b_lld_single_logF0_smo
writer.dmLevel = gemapsv01b_temporalF0
\{\cm[bufferModeRbConf]}
//nameAppend = ff0
copyInputName = 1
\{\cm[frameModeFunctionalsConf{../../shared/FrameModeFunctionals.conf.inc}:path to included config to set frame mode for all functionals]}
functionalsEnabled = Segments
Segments.maxNumSeg = 1000
Segments.segmentationAlgorithm = nonX
Segments.X = 0.0
Segments.numSegments = 1
Segments.meanSegLen = 1
Segments.maxSegLen = 0
Segments.minSegLen = 0
Segments.segLenStddev = 1
Segments.norm = second
nonZeroFuncts = 0
masterTimeNorm = second

// TODO: this is only unvoiced segments, combine with energy / loudness for true pauses!
; functionals for pitch onsets/offsets
[gemapsv01b_temporalF0p:cFunctionals]
reader.dmLevel = gemapsv01b_lld_single_logF0_smo
writer.dmLevel = gemapsv01b_temporalF0pause
\{\cm[bufferModeRbConf]}
copyInputName = 0
functNameAppend = f0pause
\{\cm[frameModeFunctionalsConf]}
functionalsEnabled = Segments
Segments.maxNumSeg = 1000
Segments.segmentationAlgorithm = eqX
Segments.X = 0.0
Segments.numSegments = 0
Segments.meanSegLen = 1
Segments.maxSegLen = 0
Segments.minSegLen = 0
Segments.segLenStddev = 1
Segments.norm = second
nonZeroFuncts = 0
masterTimeNorm = second

; functionals for pitch onsets/offsets
[gemapsv01b_temporalLoudness:cFunctionals]
reader.dmLevel = gemapsv01b_loudness_smo
writer.dmLevel = gemapsv01b_temporalLoudness
\{\cm[bufferModeRbConf]}
//nameAppend = ff0
copyInputName = 1
\{\cm[frameModeFunctionalsConf]}
functionalsEnabled = Peaks2
Peaks2.numPeaks = 1
Peaks2.meanPeakDist = 0
Peaks2.meanPeakDistDelta = 0
Peaks2.peakDistStddev = 0
Peaks2.peakRangeAbs = 0
Peaks2.peakRangeRel = 0
Peaks2.peakMeanAbs = 0
Peaks2.peakMeanMeanDist = 0
Peaks2.peakMeanRel = 0
Peaks2.ptpAmpMeanAbs = 0
Peaks2.ptpAmpMeanRel = 0
Peaks2.ptpAmpStddevAbs = 0
Peaks2.ptpAmpStddevRel = 0
Peaks2.minRangeAbs = 0
Peaks2.minRangeRel = 0
Peaks2.minMeanAbs = 0
Peaks2.minMeanMeanDist = 0
Peaks2.minMeanRel = 0
Peaks2.mtmAmpMeanAbs = 0
Peaks2.mtmAmpMeanRel = 0
Peaks2.mtmAmpStddevAbs = 0
Peaks2.mtmAmpStddevRel = 0
Peaks2.meanRisingSlope = 0
Peaks2.maxRisingSlope = 0
Peaks2.minRisingSlope = 0
Peaks2.stddevRisingSlope = 0
Peaks2.meanFallingSlope = 0
Peaks2.maxFallingSlope = 0
Peaks2.minFallingSlope = 0
Peaks2.stddevFallingSlope = 0
Peaks2.norm = seconds
Peaks2.relThresh = 0.100000
Peaks2.dynRelThresh = 0
;Peaks2.posDbgOutp = minmax.txt
Peaks2.posDbgAppend = 0
Peaks2.consoleDbg = 0
nonZeroFuncts = 0
masterTimeNorm = second

;;;;;;;;;;;;;;;;;; filtering and renaming of names ;;;;;;;;;;;

[gemapsv01b_temporalSetNames:cDataSelector]
reader.dmLevel = gemapsv01b_temporalLoudness;gemapsv01b_temporalF0;gemapsv01b_temporalF0pause
writer.dmLevel = gemapsv01b_temporalSet
\{\cm[bufferModeRbConf]}
selected = loudness_sma3_numPeaks;F0semitoneFrom27.5Hz_sma3nz_numSegments;F0semitoneFrom27.5Hz_sma3nz_meanSegLen;F0semitoneFrom27.5Hz_sma3nz_segLenStddev;F0semitoneFrom27.5Hz_sma3nz__f0pause_meanSegLen;F0semitoneFrom27.5Hz_sma3nz__f0pause_segLenStddev
newNames = loudnessPeaksPerSec;VoicedSegmentsPerSec;MeanVoicedSegmentLengthSec;StddevVoicedSegmentLengthSec;MeanUnvoicedSegmentLength;StddevUnvoicedSegmentLength

;;;;;;;;;;;;;;;;;;;;; functionals / summaries ;;;;;;;;;;;;;;;

[componentInstances:cComponentManager]
instance[gemapsv01b_functionalsF0].type=cFunctionals
instance[gemapsv01b_functionalsLoudness].type=cFunctionals
instance[gemapsv01b_functionalsMeanSpectralUV].type=cFunctionals
instance[gemapsv01b_functionalsMVRVoiced].type=cFunctionals

[gemapsv01b_functionalsF0:cFunctionals]
reader.dmLevel = gemapsv01b_lld_single_logF0_smo
writer.dmLevel = gemapsv01b_functionalsF0
\{\cm[bufferModeRbConf]}
copyInputName = 1
\{\cm[frameModeFunctionalsConf]}
functionalsEnabled = Moments ; Percentiles ; Peaks2
Moments.variance = 0
Moments.stddev = 0
Moments.stddevNorm = 2
Moments.skewness = 0
Moments.kurtosis = 0
Moments.amean = 1
Moments.doRatioLimit = 0
Percentiles.quartiles = 0
Percentiles.iqr = 0
Percentiles.percentile[0] = 0.20
Percentiles.percentile[1] = 0.50
Percentiles.percentile[2] = 0.80
Percentiles.pctlrange[0] = 0-2
Percentiles.interp = 1
Peaks2.doRatioLimit = 0
Peaks2.numPeaks = 0
Peaks2.meanPeakDist = 0
Peaks2.meanPeakDistDelta = 0
Peaks2.peakDistStddev = 0
Peaks2.peakRangeAbs = 0
Peaks2.peakRangeRel = 0
Peaks2.peakMeanAbs = 0
Peaks2.peakMeanMeanDist = 0
Peaks2.peakMeanRel = 0
Peaks2.ptpAmpMeanAbs = 0
Peaks2.ptpAmpMeanRel = 0
Peaks2.ptpAmpStddevAbs = 0
Peaks2.ptpAmpStddevRel = 0
Peaks2.minRangeAbs = 0
Peaks2.minRangeRel = 0
Peaks2.minMeanAbs = 0
Peaks2.minMeanMeanDist = 0
Peaks2.minMeanRel = 0
Peaks2.mtmAmpMeanAbs = 0
Peaks2.mtmAmpMeanRel = 0
Peaks2.mtmAmpStddevAbs = 0
Peaks2.mtmAmpStddevRel = 0
Peaks2.meanRisingSlope = 1
Peaks2.maxRisingSlope = 0
Peaks2.minRisingSlope = 0
Peaks2.stddevRisingSlope = 1
Peaks2.meanFallingSlope = 1
Peaks2.maxFallingSlope = 0
Peaks2.minFallingSlope = 0
Peaks2.stddevFallingSlope = 1
Peaks2.norm = seconds
Peaks2.relThresh = 0.100000
Peaks2.dynRelThresh = 0
;Peaks2.posDbgOutp = minmax.txt
Peaks2.posDbgAppend = 0
Peaks2.consoleDbg = 0
nonZeroFuncts = 1
masterTimeNorm = segment

[gemapsv01b_functionalsLoudness:cFunctionals]
reader.dmLevel = gemapsv01b_loudness_smo
writer.dmLevel = gemapsv01b_functionalsLoudness
\{\cm[bufferModeRbConf]}
copyInputName = 1
\{\cm[frameModeFunctionalsConf]}
functionalsEnabled = Moments ; Percentiles ; Peaks2
Moments.variance = 0
Moments.stddev = 0
Moments.stddevNorm = 2
Moments.skewness = 0
Moments.kurtosis = 0
Moments.amean = 1
Moments.doRatioLimit = 0
Percentiles.quartiles = 0
Percentiles.iqr = 0
Percentiles.percentile[0] = 0.20
Percentiles.percentile[1] = 0.50
Percentiles.percentile[2] = 0.80
Percentiles.pctlrange[0] = 0-2
Percentiles.interp = 1
Peaks2.doRatioLimit = 0
Peaks2.numPeaks = 0
Peaks2.meanPeakDist = 0
Peaks2.meanPeakDistDelta = 0
Peaks2.peakDistStddev = 0
Peaks2.peakRangeAbs = 0
Peaks2.peakRangeRel = 0
Peaks2.peakMeanAbs = 0
Peaks2.peakMeanMeanDist = 0
Peaks2.peakMeanRel = 0
Peaks2.ptpAmpMeanAbs = 0
Peaks2.ptpAmpMeanRel = 0
Peaks2.ptpAmpStddevAbs = 0
Peaks2.ptpAmpStddevRel = 0
Peaks2.minRangeAbs = 0
Peaks2.minRangeRel = 0
Peaks2.minMeanAbs = 0
Peaks2.minMeanMeanDist = 0
Peaks2.minMeanRel = 0
Peaks2.mtmAmpMeanAbs = 0
Peaks2.mtmAmpMeanRel = 0
Peaks2.mtmAmpStddevAbs = 0
Peaks2.mtmAmpStddevRel = 0
Peaks2.meanRisingSlope = 1
Peaks2.maxRisingSlope = 0
Peaks2.minRisingSlope = 0
Peaks2.stddevRisingSlope = 1
Peaks2.meanFallingSlope = 1
Peaks2.maxFallingSlope = 0
Peaks2.minFallingSlope = 0
Peaks2.stddevFallingSlope = 1
Peaks2.norm = seconds
Peaks2.relThresh = 0.100000
Peaks2.dynRelThresh = 0
;Peaks2.posDbgOutp = minmax.txt
Peaks2.posDbgAppend = 0
Peaks2.consoleDbg = 0
nonZeroFuncts = 0
masterTimeNorm = segment

[gemapsv01b_functionalsMeanSpectralUV:cFunctionals]
reader.dmLevel = gemapsv01b_lldSetSpectralZ_smo
writer.dmLevel = gemapsv01b_functionalsMeanSpectralUnvoiced
\{\cm[bufferModeRbConf]}
copyInputName = 1
\{\cm[frameModeFunctionalsConf]}
functionalsEnabled = Moments
Moments.variance = 0
Moments.stddev = 0
Moments.stddevNorm = 0
Moments.skewness = 0
Moments.kurtosis = 0
Moments.amean = 1
Moments.doRatioLimit = 0
nonZeroFuncts = 1
masterTimeNorm = segment

[gemapsv01b_functionalsMVRVoiced:cFunctionals]
reader.dmLevel = gemapsv01b_lldSetNoF0AndLoudnessNz_smo;gemapsv01b_lldSetSpectralNz_smo;
writer.dmLevel = gemapsv01b_functionalsMeanStddevVoiced
\{\cm[bufferModeRbConf]}
copyInputName = 1
\{\cm[frameModeFunctionalsConf]}
functionalsEnabled = Moments
Moments.variance = 0
Moments.stddev = 0
Moments.stddevNorm = 2
Moments.skewness = 0
Moments.kurtosis = 0
Moments.amean = 1
Moments.doRatioLimit = 0
nonZeroFuncts = 1
masterTimeNorm = segment




//\{eGeMAPSv02_core.func.conf.inc}
///////////////////////////////////////////////////////////////////////////////////////
///////// > openSMILE configuration file, Geneva feature set <       //////////////////
/////////                                                            //////////////////
///////// (c) 2014, 2020 by audEERING                                //////////////////
/////////     All rights reserved. See file COPYING for details.     //////////////////
///////////////////////////////////////////////////////////////////////////////////////


[componentInstances:cComponentManager]
instance[egemapsv02_leqLin].type= cFunctionals
instance[egemapsv02_leq].type = cVectorOperation

;; LEq
[egemapsv02_leqLin:cFunctionals]
reader.dmLevel = egemapsv02_energyRMS
writer.dmLevel = egemapsv02_leqLin
// nameAppend =
preserveFields = 1
\{\cm[bufferModeRbConf]}
copyInputName = 1
\{\cm[frameModeFunctionalsConf]}
noPostEOIprocessing = 0
functionalsEnabled = Means
Means.amean = 1
Means.posamean = 0
Means.absmean = 0
Means.qmean = 0
Means.nzamean = 0
Means.nzabsmean = 0
Means.nzqmean = 0
Means.nzgmean = 0
Means.nnz = 0

[egemapsv02_leq:cVectorOperation]
reader.dmLevel = egemapsv02_leqLin
writer.dmLevel = egemapsv02_leq
nameBase = equivalentSoundLevel
copyInputName = 1
processArrayFields = 0
operation = dBp
appendOperationToName = 1



;;;;;;;;;;;;;;;;;;;;; functionals / summaries ;;;;;;;;;;;;;;;

[componentInstances:cComponentManager]
instance[egemapsv02_functionalsMVR].type=cFunctionals
instance[egemapsv02_functionalsMeanUV].type=cFunctionals
instance[egemapsv02_functionalsMVRVoiced].type = cFunctionals

[egemapsv02_functionalsMVR:cFunctionals]
reader.dmLevel = egemapsv02_lldSetNoF0AndLoudnessZ_smo
writer.dmLevel = egemapsv02_functionalsMeanStddevZ
\{\cm[bufferModeRbConf]}
copyInputName = 1
\{\cm[frameModeFunctionalsConf]}
functionalsEnabled = Moments
Moments.variance = 0
Moments.stddev = 0
Moments.stddevNorm = 2
Moments.skewness = 0
Moments.kurtosis = 0
Moments.amean = 1
nonZeroFuncts = 0
masterTimeNorm = segment

[egemapsv02_functionalsMeanUV:cFunctionals]
reader.dmLevel = egemapsv02_lldSetSpectralZ_smo
writer.dmLevel = egemapsv02_functionalsMeanUnvoiced
\{\cm[bufferModeRbConf]}
copyInputName = 1
\{\cm[frameModeFunctionalsConf]}
functionalsEnabled = Moments
Moments.variance = 0
Moments.stddev = 0
Moments.stddevNorm = 0
Moments.skewness = 0
Moments.kurtosis = 0
Moments.amean = 1
nonZeroFuncts = 1
masterTimeNorm = segment

[egemapsv02_functionalsMVRVoiced:cFunctionals]
reader.dmLevel = egemapsv02_lldSetNoF0AndLoudnessNz_smo;egemapsv02_lldSetSpectralNz_smo
writer.dmLevel = egemapsv02_functionalsMeanStddevVoiced
\{\cm[bufferModeRbConf]}
copyInputName = 1
\{\cm[frameModeFunctionalsConf]}
functionalsEnabled = Moments
Moments.variance = 0
Moments.stddev = 0
Moments.stddevNorm = 2
Moments.skewness = 0
Moments.kurtosis = 0
Moments.amean = 1
nonZeroFuncts = 1
masterTimeNorm = segment




[componentInstances:cComponentManager]
instance[lldconcat].type=cVectorConcat
instance[funcconcat].type=cVectorConcat

[lldconcat:cVectorConcat]
reader.dmLevel = egemapsv02_lldsetE_smo;egemapsv02_lldsetF_smo
writer.dmLevel = lld
includeSingleElementFields = 1

[funcconcat:cVectorConcat]
reader.dmLevel = gemapsv01b_functionalsF0;gemapsv01b_functionalsLoudness;egemapsv02_functionalsMeanStddevZ;egemapsv02_functionalsMeanStddevVoiced;egemapsv02_functionalsMeanUnvoiced;gemapsv01b_temporalSet;egemapsv02_leq
writer.dmLevel = func
includeSingleElementFields = 1

//\{../../shared/standard_data_output_no_lld_de.conf.inc}
///////////////////////////////////////////////////////////////////////////////////////
///////// > openSMILE configuration file for data output <           //////////////////
/////////                                                            //////////////////
///////// (c) 2014-2016 audEERING,                                   //////////////////
/////////     All rights reserved. See file COPYING for details     //////////////////
///////////////////////////////////////////////////////////////////////////////////////


/*
   This file can be included as data output file for standard feature
   extraction configuration files. It provides commandline options
   for the batch extraction GUI, and supports LLD and Functionals (summaries)
   saving.

   It requires the main extractor configuration file to provide the following
   data memory levels:  lld and func

   It is identical to standard_data_output.conf.inc, apart from the fact that it
   does not expect an lld_de level.
 */

;;;;;;;;; output LLD features to CSV ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

[componentInstances:cComponentManager]
instance[lldsink].type=cCsvSink
instance[lldhtksink].type=cHtkSink
instance[lldarffsink].type=cArffSink
instance[arffsink].type=cArffSink
instance[csvsink].type=cCsvSink
instance[htksink].type=cHtkSink

[lldsink:cCsvSink]
reader.dmLevel = lld
filename=\cm[lldcsvoutput(D){?}:output csv file for LLD, disabled by default ?, only written if filename given]
instanceName=\cm[instname(N){unknown}:instance name]
append = \cm[appendcsvlld{0}:set to 1 to append to the LLD output csv file, default is not to append]
timestamp = \cm[timestampcsvlld{1}:set to 0 to suppress timestamp column, default is 1, i.e. to show timestamp in second column]
number = 0
printHeader = \cm[headercsvlld{1}:set to 0 to suppress header line with feature names, default is 1, i.e. to show header line]
errorOnNoOutput = 1

[lldhtksink:cHtkSink]
reader.dmLevel = lld
filename=\cm[lldhtkoutput{?}:output HTK binary file for LLD, disabled by default ?, only written if filename given]
append = \cm[appendhtklld{0}:set to 1 to append to the LLD output htk file, default is not to append]
  ; this is broken for HTK sink...
errorOnNoOutput = 0
parmKind = 9

[lldarffsink:cArffSink]
reader.dmLevel = lld
frameIndex = 0
frameTime = \cm[timestamparfflld{1}:set to 0 to suppress timestamp column, default is 1, i.e. to show timestamp in second column]
filename=\cm[lldarffoutput{?}:name of WEKA Arff output file, set to a valid filename to enable this output sink]
relation=\cm[relation{openSMILE_features}:arff relation attribute, feature set name and/or corpus name]
instanceName=\cm[instname]
 ;; use this line instead of the above to always set the instance name to the
 ;; name of the input wave file
 ;instanceName=\cm[inputfile]
\{\cm[lldarfftargetsfile{arff_targets.conf.inc}:name of arff targets include file]}
append=\cm[appendarfflld{1}:set to 0 to disable appending to an existing arff parameter summary file, given by the arffoutput option]
errorOnNoOutput = 1

[arffsink:cArffSink]
reader.dmLevel=func
frameIndex = 0
frameTime = \cm[timestamparff{0}:set to 1 to include timestamp column, default is 0, i.e. to not save timestamp in second column]
frameTimeAdd=\cm[frameTimeAdd{0}:frame time offset -start of segment in seconds- used by avec2013]
filename=\cm[output(O){?}:name of WEKA Arff output file, set to a valid filename to enable this output sink]
relation=\cm[relation{openSMILE_features}:arff relation attribute, feature set name and/or corpus name]
instanceName=\cm[instname]
 ;; use this line instead of the above to always set the instance name to the
 ;; name of the input wave file
 ;instanceName=\cm[inputfile]
\{\cm[arfftargetsfile{arff_targets.conf.inc}:name of arff targets include file]}
append=\cm[appendarff{1}:set to 0 to disable appending to an existing arff parameter summary file, given by the arffoutput option]
errorOnNoOutput = 1

[csvsink:cCsvSink]
reader.dmLevel = func
filename=\cm[csvoutput{?}:output CSV file for summarised parameters, set to a valid filename to enable this output sink, data is appended if file exists]
append=\cm[appendcsv{1}:set to 0 to disable appending to an existing csv parameter summary file, given by the csvoutput option]
frameIndex=0
frameTime=\cm[timestampcsv{1}:set to 0 to suppress timestamp column, default is 1, i.e. to show timestamp in second column]
instanceName=\cm[instname]
errorOnNoOutput = 1
printHeader = \cm[headercsv{1}:set to 0 to suppress header line with feature names, default is 1, i.e. to show header line]

  ; TODO: output without a frame period does not work so that HTK (HList) can read it!
[htksink:cHtkSink]
reader.dmLevel = func
filename=\cm[htkoutput{?}:output HTK file for summarised parameters, set to a valid filename to enable this output sink, no append by default, use -appendstatichtk option to enable]
append=\cm[appendhtk{0}:set to 1 to enable appending to an existing HTK parameter summary file, given by the htkoutput option]
parmKind = 9
  ; this is broken for HTK sink...
errorOnNoOutput = 0
 ; avoid broken files which HTK cannot read for period approx. > 0.06 (int16 overflow)
forcePeriod = 0.01



